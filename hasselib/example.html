<div class="highlight"><pre><span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># celle dw di una cella</span>
<span class="c"># /////////////////////////////////////////////</span>
<span class="k">def</span> <span class="nf">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">DOWNCELLS0</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
        <span class="n">it</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">goDw</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span><span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">end</span><span class="p">():</span> <span class="n">ret</span><span class="o">+=</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">getNode</span><span class="p">()];</span><span class="n">it</span><span class="o">.</span><span class="n">goForward</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">DOWNCELLS0</span>

<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># celle up di una cella</span>
<span class="c"># /////////////////////////////////////////////</span>
<span class="k">def</span> <span class="nf">UPCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">UPCELLS0</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
        <span class="n">it</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">goUp</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span><span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">end</span><span class="p">():</span> <span class="n">ret</span><span class="o">+=</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">getNode</span><span class="p">()];</span><span class="n">it</span><span class="o">.</span><span class="n">goForward</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">UPCELLS0</span>

<span class="c"># /////////////////////////////////////////////</span>
<span class="c">#  celle ad un certo livello del grafo</span>
<span class="c"># /////////////////////////////////////////////</span>
<span class="k">def</span> <span class="nf">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">CELLSPERLEVEL0</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
        <span class="n">it</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> 
        <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">end</span><span class="p">():</span>
            <span class="n">ret</span><span class="o">+=</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">getNode</span><span class="p">()];</span><span class="n">it</span><span class="o">.</span><span class="n">goForward</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>  
    <span class="k">return</span> <span class="n">CELLSPERLEVEL0</span>


<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># ad esempio per trovare tutte le 0-celle </span>
<span class="c"># /////////////////////////////////////////////</span>
<span class="k">def</span> <span class="nf">FINDCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">nav</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">FINDCELLS0</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="n">cell</span><span class="p">):</span>
        <span class="n">num</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">findCells</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">nav</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">nav</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num</span><span class="p">)]</span> 
    <span class="k">return</span> <span class="n">FINDCELLS0</span>

<span class="c"># ////////////////////////////////////////////////</span>
<span class="k">def</span> <span class="nf">GETINTERSECTION</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">GETINTERSECTION0</span><span class="p">(</span><span class="n">from_cells</span><span class="p">,</span><span class="n">up_direction</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="n">result</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">from_cells</span><span class="p">)</span>

        <span class="c"># use the Tmp info to reset the &quot;reachable&quot; info</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">from_cells</span><span class="p">:</span>
            <span class="n">it</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">goUp</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">up_direction</span> <span class="k">else</span> <span class="n">g</span><span class="o">.</span><span class="n">goDown</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">end</span><span class="p">():</span> 
                <span class="n">reached</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">getNode</span><span class="p">())</span>
                <span class="n">reached</span><span class="o">.</span><span class="n">Tmp</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">it</span><span class="o">.</span><span class="n">goForward</span><span class="p">()</span>
            
        <span class="c"># increment the &quot;reachable&quot; Tmp, if all nodes reaches one common father</span>
        <span class="c"># then the father is added to the list</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">from_cells</span><span class="p">:</span>
            <span class="n">it</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">goUp</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">up_direction</span> <span class="k">else</span> <span class="n">g</span><span class="o">.</span><span class="n">goDown</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">end</span><span class="p">():</span> 
                <span class="n">reached</span> <span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">getNode</span><span class="p">())</span>
                <span class="n">reached</span><span class="o">.</span><span class="n">Tmp</span><span class="o">=</span><span class="n">reached</span><span class="o">.</span><span class="n">Tmp</span><span class="o">+</span><span class="mi">1</span>   
                <span class="k">if</span> <span class="n">reached</span><span class="o">.</span><span class="n">Tmp</span><span class="o">==</span><span class="n">num</span><span class="p">:</span> 
                    <span class="n">result</span><span class="o">+=</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">getNode</span><span class="p">()]</span>
                <span class="n">it</span><span class="o">.</span><span class="n">goForward</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">GETINTERSECTION0</span>

<span class="c">###################################################################</span>

<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># Generation of 1D polyhedron</span>
<span class="c"># /////////////////////////////////////////////</span>

<span class="k">def</span> <span class="nf">Quote</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">numList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; To create the graph of a 1D cell complex &quot;&quot;&quot;</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numList</span><span class="p">]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vecf</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AL</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">PROGRESSIVESUM</span><span class="p">(</span><span class="n">sizes</span><span class="p">)])]</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span> <span class="n">node</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">g</span><span class="o">.</span><span class="n">setVecf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">point</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">numList</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="n">g</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="c">#aggiungi la doppia connettivita&#39; dei nodi a livello top</span>
            <span class="n">g</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span><span class="n">g</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">remNode</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">g</span>
    

<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># Generation of nD grids</span>
<span class="c"># /////////////////////////////////////////////</span>

<span class="k">def</span> <span class="nf">Grid</span><span class="p">(</span><span class="n">listOfListsOfNum</span><span class="p">):</span>
    <span class="n">numList</span> <span class="o">=</span> <span class="n">listOfListsOfNum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Quote</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">numList</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">numList</span> <span class="ow">in</span> <span class="n">listOfListsOfNum</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">Quote</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">numList</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">Matf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Matf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>  <span class="n">g</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span>  <span class="n">g1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># Centroid operator</span>
<span class="c"># /////////////////////////////////////////////</span>


<span class="k">def</span> <span class="nf">CENTROID</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">CENTROID0</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the centroid of a cell.</span>
<span class="sd">            Returns a value of class pyplasm.xge.xgepy.Vecf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">Level</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">getVecf</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">g</span><span class="o">.</span><span class="n">Level</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">CAT</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="n">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">))(</span><span class="n">out</span><span class="p">))))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">getVecf</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">out</span><span class="p">]</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">VECTSUM</span><span class="p">([[</span><span class="n">point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">getPointDim</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">SCALARVECTPROD</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">centroid</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Vecf</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CENTROID0</span>


<span class="c">###################################################################</span>

<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># Drawing 3-cells of Graph instances with Hpc</span>
<span class="c"># /////////////////////////////////////////////</span>

<span class="k">def</span> <span class="nf">graph2hexs</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">graph2hexs0</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">UPCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">]</span>
        <span class="n">cellverts</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">g</span><span class="o">.</span><span class="n">getVecf</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
                 <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cell</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">MKPOL</span><span class="p">([</span><span class="n">verts</span><span class="p">,[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="bp">None</span><span class="p">])</span> <span class="k">for</span> <span class="n">verts</span> <span class="ow">in</span> <span class="n">cellverts</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">graph2hexs0</span>

<span class="k">def</span> <span class="nf">SHOW</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">VIEW</span><span class="p">(</span><span class="n">EXPLODE</span><span class="p">(</span><span class="o">*</span><span class="n">expl</span><span class="p">)(</span><span class="n">graph2hexs</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="mi">3</span><span class="p">))))</span>


<span class="c">###################################################################</span>

<span class="c"># /////////////////////////////////////////////</span>
<span class="c"># Drawing Graph instances with spheres and cylinders</span>
<span class="c"># /////////////////////////////////////////////</span>


<span class="k">def</span> <span class="nf">DRAW</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getMaxDimCells</span><span class="p">()</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getPointDim</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">scaledpoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">expl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">vect</span> <span class="o">=</span> <span class="n">VECTDIFF</span><span class="p">([</span><span class="n">scaledpoint</span><span class="p">,</span><span class="n">point</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">vect</span>
        

    <span class="k">def</span> <span class="nf">spheres</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">batches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="n">unitSphere</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">openObj</span><span class="p">(</span><span class="s">&quot;sphere18x27.obj&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">batchSphere</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">unitSphere</span><span class="p">)</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">point</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
                <span class="n">vect</span> <span class="o">=</span> <span class="n">vect</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
            <span class="n">batchSphere</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span>  <span class="n">Mat4f</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">*</span><span class="n">vect</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">Mat4f</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">)</span><span class="o">*</span><span class="n">Mat4f</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="n">sx</span><span class="p">,</span><span class="n">sx</span><span class="p">)</span>
            <span class="n">batchSphere</span><span class="o">.</span><span class="n">diffuse</span><span class="o">=</span><span class="n">CYAN</span>
            <span class="n">batches</span> <span class="o">+=</span> <span class="p">[</span><span class="n">batchSphere</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">batches</span>


    <span class="k">def</span> <span class="nf">transfCylr</span><span class="p">(</span><span class="n">batchCylinder</span><span class="p">,</span><span class="n">pointpair</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">vect</span><span class="p">,</span><span class="n">point</span> <span class="o">=</span> <span class="n">VECTDIFF</span><span class="p">(</span><span class="n">REVERSE</span><span class="p">(</span><span class="n">pointpair</span><span class="p">)),</span><span class="n">pointpair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="mf">0.025</span>
        
        <span class="k">def</span> <span class="nf">vectTransform</span><span class="p">(</span><span class="n">vect</span><span class="p">):</span>
            <span class="n">qz</span> <span class="o">=</span> <span class="n">UNITVECT</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
            <span class="n">qx</span> <span class="o">=</span> <span class="n">UNITVECT</span><span class="p">(</span><span class="n">VECTPROD</span><span class="p">([</span> <span class="n">vect</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]))</span>
            <span class="n">qy</span> <span class="o">=</span> <span class="n">VECTPROD</span><span class="p">([</span> <span class="n">qz</span><span class="p">,</span><span class="n">qx</span> <span class="p">])</span>
            <span class="n">Rot</span> <span class="o">=</span> <span class="n">TRANS</span><span class="p">([</span><span class="n">qx</span><span class="p">,</span><span class="n">qy</span><span class="p">,</span><span class="n">qz</span><span class="p">])</span> 
            <span class="n">Rot</span> <span class="o">=</span> <span class="n">CAT</span><span class="p">([</span> <span class="n">Rot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="n">Rot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="n">Rot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]</span> <span class="p">])</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">VECTNORM</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
            
            <span class="k">def</span> <span class="nf">isclose</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">filter_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">&lt;</span><span class="n">filter_threshold</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">isclose</span> <span class="p">(</span><span class="n">Mat4f</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">Mat4f</span><span class="p">(</span><span class="o">*</span><span class="n">Rot</span><span class="p">)),</span>
                        <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1E-5</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">h</span><span class="p">,</span><span class="n">Mat4f</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">SIGN</span><span class="p">(</span><span class="n">vect</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">SIGN</span><span class="p">(</span><span class="n">vect</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">h</span><span class="p">,</span><span class="n">Mat4f</span><span class="p">(</span><span class="o">*</span><span class="n">Rot</span><span class="p">)</span>
            
        <span class="n">h</span><span class="p">,</span><span class="n">rot</span> <span class="o">=</span> <span class="n">vectTransform</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">VECTSUM</span><span class="p">(</span><span class="n">pointpair</span><span class="p">)]</span>
        <span class="n">vect</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
        <span class="n">batchCylinder</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">Mat4f</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">*</span><span class="n">vect</span><span class="p">)</span> <span class="o">*</span>\
            <span class="n">Mat4f</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">)</span> <span class="o">*</span> <span class="n">rot</span> <span class="o">*</span> <span class="n">Mat4f</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="n">sx</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">batchCylinder</span><span class="o">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">MAGENTA</span>
        <span class="k">return</span> <span class="n">batchCylinder</span>

    <span class="k">def</span> <span class="nf">cylinders</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span><span class="n">edgepoints</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">unitCylinder</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">openObj</span><span class="p">(</span><span class="s">&quot;cylinder4x27.obj&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        
        <span class="n">vects</span> <span class="o">=</span> <span class="p">[</span><span class="n">VECTDIFF</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edgepoints</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pointpair</span> <span class="ow">in</span> <span class="n">edgepoints</span><span class="p">:</span>
            <span class="n">batchCyl</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">unitCylinder</span><span class="p">)</span>
            <span class="n">batchCyl</span> <span class="o">=</span> <span class="n">transfCylr</span><span class="p">(</span><span class="n">batchCyl</span><span class="p">,</span><span class="n">pointpair</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
            <span class="n">batches</span> <span class="o">+=</span> <span class="p">[</span><span class="n">batchCyl</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">batches</span>

    <span class="k">def</span> <span class="nf">planecells</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span><span class="n">facepoints</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">facepoints</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">VECTSUM</span><span class="p">(</span><span class="n">points</span><span class="p">)]</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">point</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">vect</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
            <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">SIGN</span><span class="p">(</span><span class="n">VECTPROD</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">VECTDIFF</span><span class="p">)(</span><span class="n">center</span><span class="p">))(</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">MKPOL</span><span class="p">([</span><span class="n">points</span><span class="p">,[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="bp">None</span><span class="p">])</span>
            <span class="n">faceBatch</span> <span class="o">=</span> <span class="n">Plasm</span><span class="o">.</span><span class="n">getBatches</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
            <span class="n">faceBatch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">WHITE</span>
            <span class="n">batches</span> <span class="o">+=</span> <span class="n">faceBatch</span>
        <span class="k">return</span> <span class="n">batches</span>

    <span class="k">def</span> <span class="nf">cells</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span><span class="n">cellpoints</span><span class="p">,</span><span class="n">expl</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">cellpoints</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">VECTSUM</span><span class="p">(</span><span class="n">points</span><span class="p">)]</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">point</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">vect</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">MKPOL</span><span class="p">([</span><span class="n">points</span><span class="p">,[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="bp">None</span><span class="p">])</span>
            <span class="n">cellBatch</span> <span class="o">=</span> <span class="n">Plasm</span><span class="o">.</span><span class="n">getBatches</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">cellBatch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">YELLOW</span>
            <span class="n">batches</span> <span class="o">+=</span> <span class="n">cellBatch</span>
        <span class="k">return</span> <span class="n">batches</span>

    <span class="k">def</span> <span class="nf">DRAW0</span><span class="p">(</span><span class="n">chain</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">getNumNode</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getPointDim</span><span class="p">()</span>

        <span class="n">chains</span> <span class="o">=</span> <span class="p">[[],[],[],[]]</span>
        <span class="p">[</span><span class="n">chains</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">Level</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>                
        <span class="n">nodepoints</span> <span class="o">=</span> <span class="p">[[</span><span class="n">g</span><span class="o">.</span><span class="n">getVecf</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                      <span class="k">if</span> <span class="n">m</span><span class="o">&gt;</span><span class="mi">2</span> <span class="k">else</span>
                      <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">getVecf</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">REVERSE</span><span class="p">(</span><span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="mi">0</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="n">m</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">vertpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodepoints</span><span class="p">[</span><span class="n">vert</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">edge</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">edgepoints</span> <span class="o">=</span> <span class="p">[[</span><span class="n">nodepoints</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">facesAsEdges</span> <span class="o">=</span> <span class="p">[</span><span class="n">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">face</span><span class="p">)</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">facesAsVerts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">CAT</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="n">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">))(</span><span class="n">face</span><span class="p">))))</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">facesAsEdges</span><span class="p">]</span>
            <span class="n">facepoints</span> <span class="o">=</span> <span class="p">[[</span><span class="n">nodepoints</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">facesAsVerts</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">solidcells</span> <span class="o">=</span> <span class="p">[</span><span class="n">UPCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
                <span class="n">cellpoints</span> <span class="o">=</span> <span class="p">[[</span><span class="n">nodepoints</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cell</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">solidcells</span><span class="p">]</span>

        <span class="c">#this is the list of batches you want to display</span>
        <span class="n">batches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">batches</span> <span class="o">=</span> <span class="n">spheres</span><span class="p">(</span><span class="n">vertpoints</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">batches</span> <span class="o">=</span> <span class="n">cylinders</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span><span class="n">edgepoints</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">batches</span> <span class="o">=</span> <span class="n">planecells</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span><span class="n">facepoints</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chains</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="n">batches</span> <span class="o">=</span> <span class="n">cells</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span><span class="n">cellpoints</span><span class="p">,</span><span class="n">expl</span><span class="p">)</span>

        <span class="c"># organize the batch in a loose octree</span>
        <span class="n">octree</span><span class="o">=</span><span class="n">Octree</span><span class="p">(</span><span class="n">batches</span><span class="p">)</span>

        <span class="c"># create the viewer and run it</span>
        <span class="n">viewer</span><span class="o">=</span><span class="n">Viewer</span><span class="p">(</span><span class="n">octree</span><span class="p">)</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">DRAW0</span>

<span class="c">###################################################################</span>

<span class="c"># ////////////////////////////////////////////////////////</span>
<span class="c"># Meshing with d-hypercubes (HCC - Hyper-Cuboidal-Complex)</span>
<span class="c"># ///////////////////////////////////////////////////////</span>

<span class="k">def</span> <span class="nf">hccmesh</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    
    <span class="n">d</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getMaxDimCells</span><span class="p">()</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">getfathers</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">GETINTERSECTION</span><span class="p">(</span><span class="n">g1</span><span class="p">)([</span><span class="nb">tuple</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">tuple</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="k">def</span> <span class="nf">grouping</span><span class="p">(</span><span class="n">tuples</span><span class="p">):</span>
        <span class="n">out</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[[</span><span class="n">tuples</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="n">first</span><span class="p">,</span><span class="n">last</span> <span class="o">=</span> <span class="n">tuples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">tuples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">tuples</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tuples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">tuples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">):</span>
                <span class="n">groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tuples</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tuples</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                <span class="n">first</span><span class="p">,</span><span class="n">last</span> <span class="o">=</span> <span class="n">tuples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">tuples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">groups</span>

    <span class="k">def</span> <span class="nf">multiTraverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">nrecursion</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">up_direction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">multitraverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">nrecursion</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">up_direction</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nrecursion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[[</span><span class="n">cell</span><span class="p">]]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">Down</span> <span class="ow">in</span> <span class="n">DOWNCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">cell</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">up_direction</span> <span class="k">else</span> <span class="n">UPCELLS</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">cell</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cell</span><span class="p">]</span> <span class="o">+</span> <span class="n">L</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span>
                        <span class="n">multitraverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">nrecursion</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Down</span><span class="p">,</span><span class="n">up_direction</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">grouping</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="n">REVERSE</span><span class="p">)(</span>
            <span class="n">multitraverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">nrecursion</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">up_direction</span><span class="p">))))</span>   

    <span class="k">def</span> <span class="nf">backTraverse</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">backtraverse</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">COMP</span><span class="p">([</span><span class="nb">list</span><span class="p">,</span><span class="nb">set</span><span class="p">,</span><span class="n">CAT</span><span class="p">,</span><span class="n">AA</span><span class="p">(</span><span class="n">COMP</span><span class="p">([</span><span class="n">CAT</span><span class="p">,</span><span class="n">getfathers</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)))])</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">CAT</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">backtraverse</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    
    <span class="c"># init step: store contraction vertices</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">g</span><span class="o">.</span><span class="n">setVecf</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="n">CENTROID</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">cell</span><span class="p">))</span>

    <span class="c"># create the 0-layer of HCC</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">getNumNode</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">newnode</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">g1</span><span class="o">.</span><span class="n">setVecf</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">getVecf</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        
    <span class="c"># create higher level layers of HCC</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="c"># create Nk and Ak</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">REVERSE</span><span class="p">(</span><span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">h</span><span class="p">)):</span>
                <span class="c"># forward search in g for the isomorphic subgraphs</span>
                <span class="n">subgraphs</span> <span class="o">=</span> <span class="n">multiTraverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">root</span><span class="p">)</span>
                <span class="c"># backtrack upon g1: looking for (k-1)-faces of each newnode</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">backTraverse</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">nodePaths</span><span class="p">)</span> <span class="k">for</span> <span class="n">nodePaths</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">]</span>
                <span class="c"># build the k-layer of HCC</span>
                <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                    <span class="n">newnode</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
                        <span class="n">g1</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">newnode</span><span class="p">)</span>                            

    <span class="c"># create the last layer of HCC</span>
    <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">REVERSE</span><span class="p">(</span><span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">d</span><span class="p">)):</span>
        <span class="n">subgraphs</span> <span class="o">=</span> <span class="n">multiTraverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">root</span><span class="p">)</span>
        <span class="n">facets</span> <span class="o">=</span> <span class="p">[</span><span class="n">backTraverse</span><span class="p">(</span><span class="n">d</span><span class="p">)(</span><span class="n">nodePaths</span><span class="p">)</span> <span class="k">for</span> <span class="n">nodePaths</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">CAT</span><span class="p">(</span><span class="n">nodePaths</span><span class="p">)))</span> <span class="k">for</span> <span class="n">nodePaths</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">]</span>

        <span class="c"># build the d-layer of HCC</span>
        <span class="k">for</span> <span class="n">facet</span><span class="p">,</span><span class="n">verts</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">facets</span><span class="p">,</span><span class="n">vertices</span><span class="p">):</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">facet</span><span class="p">:</span>
                <span class="n">g1</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">newnode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                <span class="n">g1</span><span class="o">.</span><span class="n">addArch</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span><span class="n">vert</span><span class="p">)</span>                                                                
        
    <span class="c"># return the output HCC graph</span>
    <span class="k">return</span> <span class="n">g1</span>

<span class="k">def</span> <span class="nf">hccMeshSize</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([[</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">hccmesh</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">CELLSPERLEVEL</span><span class="p">(</span><span class="n">g1</span><span class="p">)(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">hccmesh</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">VIEW</span><span class="p">(</span><span class="n">SKELETON</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">Hpc</span><span class="p">(</span><span class="n">g</span><span class="p">)))</span>
    <span class="n">SHOW</span><span class="p">(</span><span class="n">g</span><span class="p">,[</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">])</span>
    <span class="n">DRAW</span><span class="p">(</span><span class="n">g</span><span class="p">,[</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">])()</span>
    
<span class="c">##    myprint(&quot;hccMeshSize(1)&quot;,hccMeshSize(1))</span>
<span class="c">##    myprint(&quot;hccMeshSize(2)&quot;,hccMeshSize(2))</span>
<span class="c">##    myprint(&quot;hccMeshSize(3)&quot;,hccMeshSize(3))</span>
<span class="c">##    myprint(&quot;hccMeshSize(4)&quot;,hccMeshSize(4))</span>
<span class="c">##    myprint(&quot;hccMeshSize(5)&quot;,hccMeshSize(5))</span>
    
    <span class="n">g</span> <span class="o">=</span> <span class="n">hccmesh</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">SHOW</span><span class="p">(</span><span class="n">g</span><span class="p">,[</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">])</span>
</pre></div>
